## 链表与指针

**链表** 数据元素的线性集。
**点** 链表中的数据元素。其借助指针域给出线性序。
分为两个部分，一部分包含元素的信息，一部分包含后继点的地址信息。

**链域** 点中包含链表中后继点的地址的部分，也叫**后继指针域**。

**空指针** 指向无效地址的指针。通常用于指明链表的结尾。

## 堆栈、队列、优先队列

**堆栈** 也称为后进先出（LIFO）系统，它是一个仅在表的称为顶的一端进行插入和删除的线性表。

**队列** 也称为先进先出（FIFO）系统，它只能在表的称为前面的一端进行删除，而在称为后面的另一端进行插入。

**优先队列** 新元素可以定期的插入，但是总是先删除当前具有最高优先级的元素的一个元素样。

## 图与多重图

一个图G由两个对象构成：
    1. 集合V = V(G)，其元素称为G的**顶点**或**点**。
    2. 集合E = E(G)，其元素为G的不同顶点的无序偶，称为G的边。

当强调G的两个部分时，用G(V,E)表示这样的图。

**相邻，端点**

若存在一个边 e = {u, v}，则称顶点u和v为**相邻**的，此时u与v称为e的**端点**，而称e连接u和v，也称边e **关联于** 它的端点u和v。

### 多重图

重边：如果存在边e1 和 e2 连接相同的端点，则称为重边。

环：若边e的两个端点是同一顶点，则称e为环。

简单图：没有重边和环的图。

多重图：存在重边和环的图。

## 顶点的度

图G中的顶点v的度 deg(v) 等于G中含有v的边的条数，即关联于v的边数。

由于计算G中顶点的度时，每条边被计数两次，于是有：

**定理8.1** G中顶点的度之和等于G中边数的2倍。

此定理对于多重图也成立，但环对环的端点的度要算两次（即环当成是首未顶点相同的边）。

**奇点、偶点**

偶点：度是偶数的顶点。

奇点：度是奇数的顶点。

孤立点：度为0的顶点。

### 有限图、平凡图

有限图：若多重图的顶点数和边都是有限的，则称它为有限的。

平凡图：具有一顶点而没有边的图，称为平凡图。（即单点）

## 子图，同构，同胚图

### 子图

考虑图G = G(V, E)，存在 H = H(V', E')，使得H的顶点和边分别包含于G的顶点和边，即:

$$
V' \subseteq V \land E' \subseteq E
$$

特别地：

    1. 若边集E'包含了G中端点在H中的所有边，则称图H(V', E')为图G(V, E)的由顶点V'导出的子图；

    2. 若v为G的一个顶点，则 G-v 记号表示 G 的从G中删去顶点v及G中含v的所有边所得到的子图。

    3. 若e为G的一条边，则 G-e 记号表示 从G中只删除边e所得到G的子图（顶点保留）。

### 同构图

对于图G(V, E)和 图G^*(V^*, E^*)，
如果存在一个一一对应 f: V \to V^* r使得{u, v}为G的边当且仅当{f(u), f(v)}为G^*的边。

### 同胚图

若两个图是由相同的图或同构的图用另外的点剖分某个边得到一个新的图，则称为是同胚的。

## 路、连通度

### 路

多重图G的路是由形如：

$$$
v_0, e_1, v_1, e_2, v_2, ..., e_{n-1}, v_{n-1}, e_n, v_n
$$$

的点边交替序列构成，其中每个边 e_i 含有顶点 v_{i-1} 和 v_i（它们位于序列中 e_i 的两旁）。

**路的长度** 边数 n 称为这条路的长度。

也可以用点序列 (v_0, v_1, ..., v_n) 表示路。
若 v_0 = v_n，则称这条路是*闭*的，否则称为 连接 v_0 到 v_n 的路。

**简单路** 顶点都不相同的路
**迹** 边互不相同的路称为迹
**圈** 除了 v_0 = v_n 外，其余顶点互不相同的闭路。长度为k的圈称为 k-圈。

**定理8.2** 存在从 顶点u 到 顶点v 的路 当且仅当 存在从 u 到 v 的简单路。

### 连通度，连通分支

**连通** 如果图G的任意两点之间都存在一条路，则称为连通的。

**连通分支** G的一个连通子图H称为G的连通分支。

**孤立点** deg(G) = 0.孤立点本身构成一个连通分支。

### 距离与直径

**距离** 对于连通图G，G中顶点u与v之间的距离 d(u, v) 就是 u 与 v 之间最短路的长度。

**直径** G为G中任两点之间距离的最大值。记为 diam(G)。

### 割点与桥

**割点** 设G为连通图，v 为 G 的顶点，如果 G-v 不连通，则称v为割点。
（G-v 为从G中删去v以及含有v的所有边得到的图）

**桥** 设G为连通图，e 为 G 的边，如果G-e不连通，则称e为桥。
（G-e 为从G中删去边e所得到的图）

## Konigsberg桥，可旅行多重图

**Euler迹** 对于图G，*闭*且可旅行迹称为Euler迹。

**Euler图** 如果G存在Euler迹，则称为Euler图。

**定理8.3 (Euler)** 有限连通图是Euler图当且仅当其每个顶点的度数为偶数。

**推论8.4** 两个奇点的有限连通图是可旅行的，可旅行迹可以从任一奇点开始，另一奇点结束。

## Hamilton图

Hamilton回路 图G的一条经过每个顶点恰一次的闭路。

Hamilton图 存在Hamilton回路的图。

定理8.5 设G为n个顶点的连通图，若n >= 3，且对G的每个顶点 v 有 deg(v) >= n，则G为Hamilton图。

## 标号图与赋权图

**标号图** 对于图G，如果它的边与/或顶点被指定一种或另一种数据，称则G为标号图。

**赋权图** 如果标号图的每条边e都被指派一个称为e的**杈**或**长度**的非负数。

## 完全图、正则图与二部图

**完全图** 对于图G，如果G的每个顶点都与G中的每个其他顶点有边相连接，则图G称为完全图。
完全图必是连通的。n个顶点的完全图记为K_n。

**正则图** 对于图G，如果G的每个顶点的度为k，则称图为k度正则的，或 k-正则的。
换句话说，如果每个顶点有相同的度，则图是正则的。

因为顶点的度之和为偶数，所以3-正则图必有偶数个顶点。（定理8.1）

**二部图** 对于图G，如果它的顶点集V可以划分为两个子集M和N，使得G的每条边连接M的一个点到N的一个点，
完全二部图是指M的每个顶点连到N的每个顶点。这种图标记为K_{m,n}，其中m为M中的顶点数，n为N中的顶点数，
且为标准化，约定m <= n。

## 树图

对于图T，如果T是*连通*的，且没有*圈*，则称为树。

**退化树** 没有边的单个顶点的树称为退化树。

对于树T，T的两点之间只有一个简单树。
  a. 假设T中没有边 {u, v}，则对T添加边e = {u, v}后，则T的从u到v的简单路与e构成一个圈，T不再是树；
  b. 假设e = {u, v} 为T的一条边，并从T中删除e，则T不再连通，T不再是树；

定理8.6 设G为n > 1 个顶点的图，则下列结论等价：
    1. G 是 树；
    2. G 为无圈图，且有 n - 1条边；
    3. G 连通，且有 n - 1 条边；

### 支撑树

**支撑树** 对于连通图GG，如果G的子图T是树且包含了G的所有顶点，则T称为G的支撑树。

**最小支撑树** 设G为连通的赋权图，则G的每个支撑树都被指定了一个T中的每个边的权之和的总权。
G的**最小支撑树**就是总权尽可能小的支撑树。

#### 求n个顶点连通赋权图的最小支撑树的算法

**算法8.8A** 输入n个顶点的连通赋权图G，
    1. 按权递减的序排列G的边
    2. 相继地依序删去未使G不连通的边，直到剩下n - 1 条边
    3. 退出

**算法8.8B(Kruskal)** 输入n个顶点的连通赋权图G
    1. 按权的递增的序排列G的边
    2. 仅用G的顶点，相继依序添加不产生圈的边，直到添加了n - 1条边
    3. 退出

## 平面图

**平面图** 能够画在平面上使得它的边不相交叉的图或多重图称为平面图。（这是一个类拓扑的概念）

（树图是最基本的平面图）

### 地图、区域

**地图** 有限平面多重图的特定平面表示称为地图。

如果地图的基础多重图是*连通*的，则称地图是*连通*的。

**定理8.7** 地图区域的度的和等于边数的两倍。

## Euler公式

对于任何连通地图的顶点数V，边数E以及区域数R：

**定理8.8(Euler)** V - E + R = 2

（注意：前提是地图的基础图必须连通）

**定理8.9** 设 G 为连通平面图，有p个顶点和q条边，p >= 3，则 q <= 3p - 6.

### 非平面图，Kuratowski定理

定理8.10（Kuratowski） 图是非平面的当且仅当它含有同胚于 K_{3,3} 或 K_{5} 的子图。

## 图着色

**着色** 对于图G，G的顶点着色，简称着色，是给G的每个顶点指定一个颜色，使得相邻顶点有不同的颜色。
若存在用n种颜色的G的着色，则称G为 n-可着色的。

染色G所需的最少颜色数称为G的色数，记为：

$$
\chi(G)
$$

### 图G着色的算法

**算法8.10** (Welch-Powel) 输入一个图G
  1. 根据**度**递减的次序排列G的顶点
  2. 给第一个顶点染第一种颜色C1，然后，依次序给与前面已染C1的点不相邻的点染C1
  3. 用第二种颜色对未染色的子序列重列重复2
  4. 用第三种颜色，第四种颜色...，重复3，直到所有的点都已染色
  5. 退出

**定理8.11** 对图G，下面结论等价：
  1. G为2-可着色的
  2. G为二部图
  3. G的每个圈有偶长度

**定理8.12** 任何平面图是5-可着色。

**四色定理（Apple和Haken）** 任意平面图是4-可着色的。

### 对偶地图与四色定理

对于地图M，若M的两个区域有公共边，则称为相邻的。对M的着色是指对M的区域的颜色指派，使得相邻的区域有不同的颜色。
若存在M的用n个颜色的着色，则称M是n-可着色的。

地图的着色等于个平面图的顶点着色。

**对偶图** 对于地图M，在M的每个区域内取一个点，若邻区域有公共边，则用一条通过这条公共边的曲线连接相应的两个点，
这些曲线可以画得互不相交，则得到一个新的地图M*，称为M的对偶。

可以证明，M也为M*的对偶。

地图M的任意区域的着色对应对偶地图 M* 的顶点着色。因此，M是n-可着色的当且仅当对偶地图 M* 的平面图是顶点n-可着色的。

**四色定理（Apple和Haken）** 要使任意地图M的相邻区域着不同颜色，则至多需要4种颜色。

## 在计算机中储存图

设图G有m个顶点n条边，
如果m = O(n^2)，则称图G是**稠密**的；
如果 m = O(n)或 O(n log n)，则图G是**稀疏**的。

**序列表示** 采用图的邻接矩阵A表示；当图稠密时，常用矩阵来表示。

**链表示** 又称 **邻接结构**，采用邻点的链表；当图稀疏时，常采用链表表示。

### 邻接矩阵

设G 为m 个顶点的图，并设顶点已排序为 v1, v2, ..., vm，则图G的邻接矩阵 A = [a_ij] 就是如下
定义的 m * m 矩阵：

a_ij = 1 若 vi 连接到 vj，否则 0

若G为多重图，常用a_ij表示边 {vi, vj} 的数目
若G为赋权图，常用a_ij表示边 {vi, vj} 的权

### 链表示

当图是稀疏的情况下，或者需要动态删除、添加顶点的情况下，矩阵法有很大的限制；
因此需要使用一种叫**邻接结构**的链来表示图。

使用顶点与其邻接点（邻点）的形式来表示图G。用符号空集表示空邻接。
通常含有两个文件（或纪录集），一个称为点文件，另一个称为边文件。

  1. 点文件 包含图G的顶点列表。
  2. 边文件 包含图G的边。

## 图算法

查找算法过程中，G的每个顶点 N 处于三种状态之一，称为N的状态（status）：
  1. status = 1, 准备状态，顶点N的初始状态
  2. status = 2，等候状态，顶点N在等候表中，等待进行
  3. status = 3，检查状态，顶点N已检查

### 深度优先查找（DFS）

算法8.12A（深度优先查找） 该算法从一个开始点A开始执行图G的深度优先查找

  1. 初始化所有点到准备状态
  2. 从初始点A放到堆栈上，并将A的状态改为等候状态
  3. 重复4和5，直到堆栈空
  4. 取堆栈的顶点N，检查N，并置status(N) = 3，检查状态
  5. 检查N的每个邻点J
     a. 若status(J) = 1 ，把J放到堆栈上，重置status(J) = 2
     b. 若status(J) = 2，从堆栈中删去前一个J，把当前J放到堆栈上
     c. 若status(J) = 3，略过顶点J
  6. 退出

## 广度优先查找（BFS）

算法8.12B（广度优先查找） 该算法执行图G的度度优先查找，它从一个起点A开始

  1. 初始化所有点到准备状态
  2. 从初始点A放进队列，并将A的状态改为等候状态
  3. 重复4和5，直到堆栈空
  4. 移去队列的前面点 N，检查 N，并置status(N) = 3，检查状态
  5. 检查N的每个邻点J
     a. 若status(J) = 1 ，把J加到队列后面，重置status(J) = 2
     b. 若status(J) =  2或status(J) = 3，跳过顶点J[结束步骤3循环]
  6. 退出
