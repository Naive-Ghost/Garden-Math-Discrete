# 形式语言、形式语法和自动机

## 字母表，字符串，自由半群

字母表：非空符号集合（通常记作A）

字符串：字母表元素中的有限序列（通常记作 w, u, v）

空串：没有字符的序列（通常使用希腊字母 lambda 或 epsilon表示）

A 中所有字符串的集合记为 A*（读作 A 星）

字符串长度：记作 |u| 或 l(u)，表示 字符串u 中字符的个数。l(\lambda) = 0.

### 连接

对于字母表A中的两个字符串 u 和 v，连接 u 和 v 记作 uv，表示字符串 v 紧接着写在字符串 u 之后。

定理13.1 字母表A中的字符串的连接运算满足结合律，空串是运算中的单位元。
（一般地，运算的交换律不成立）

### 子串，前缀

子串：对于任意字符串 u = a1 a2 ... an,任何序列 w = a_ {j} a_ {j+1} ... a_k 称作u的子串。
前缀：子串 w = a1 a2 ... ak，以u的字符开头，称作 u 的前缀。

### 自由半群，自由幺半群

自由半群：用F表示字母表A中所有非空字符串的集合，并且含有连接运算。由于连接运算满足结合律，因此F是一个**半群**。
称作 *A 的自由半群* 或 *由 A 生成的自由半群*。
当需要标明集合A时，A的自由半群记作 F_A。

自由幺半群：设 M = A* 是包括空串lambda在内的A中所有字符串的集合。由于lambda是连接运算的单位元，M是含幺半群，我们称 M为A上的自由幺半群。

$$
F_A = A^* - \{\lambda\}
$$

## 形式语言

形式语言：字母表 A 中的字符串的集合 称为 A 上的形式语言 L。

因此，形式语言 L 是 A* 的一个子集。

### 形式语言的运算

假设 L 和 M 是 A 的形式语言，那么 L 和 M 的连接，记为 LM，是 A 上的一种形式语言，定义如下：

$$
LM = {uv: u \in L, v \in M}
$$

形式语言的幂：形式语言 L 的幂定义如下：

$$
L^0 = \{\lambda\}, L^1 = L, L^2 = LL, L^{m + 1} = L^mL(m > 1)
$$

一元运算 L* （读作 “L星”），称作 L 的 Kleene 闭包，
$$
L^* = L^0 \cup L^1 \cup L^2 \cup \cdots = \cup_{k = 0}^{\infty} L^k
$$

定理13.2 L* 的定义与 A* 一致。

此外，记号 L+ 表示：
$$
L^+ = L^* - L^0
$$

## 正则表达，正则语言

**定义** 下面每一项均为字母表A中的正则表达：

    1. 符号\lambda（空串） 和括号()（空表达）是正则表达；
    2. A中每个字母a是正则表达
    3. 如果r是正则表达，那么(r*)是正则表达
    4. 如果 r1 和 r2 是正则表达，那么 (r1 \lor r2)是正则表达；
    5. 如果 r1 和 r2 是正则表达，那么 (r1r2) 是正则表达；

  注意： 正则表达r 是一种特殊的字符串，它用A中的字符和如下五种符号：
$$
  ( ) * \lor \lambda
$$
  此外，没有其它符号用于正则表达。

**定义** A 上的形式语言 L(r) 由正则表达 r 定义如下：
    1. L(\lambda) = {\lambda} 和 L(()) = \emptyset（空集）
    2. L(a) = a，其中 a 是 A 中的字符串
    3. L( r* ) = (L(r))* ；L(r) 的 Kleen闭包
    4. L(r1 \lor r2) = L(r1) \cup L(r2)； 形式语言的并集
    5. L(r1 r2) = L(r1)L(r2) (形式语言的连接)

**定义** 设 L 为 A 的形式语言，若存在 A 上的一正则表达式，使得 L = L(r)，则L称为 A 的正则语言。

## 有限自动机

有限自动机(FSA)，或者简单地说，自动机 M，由下述五部分组成：
    1. 一个有限的输入集合A（字母表）
    2. （内部的）一个有限状态集合S
    3. S 的一个子集Y（Y的元素称为接受状态, yes）
    4. S的初始状态s_0
    5. S中的状态转移函数 F:S \times A -> S

当要指明它的五部分时，自动机M被记为：
$$
M = (A, S, Y, s_0, F)
$$

状态转移函数：
对每个 a \in A，定义 f_a: S \to S；即每一个输入a可看作引起自动机 M 的状态改变。
F(s, a) = f_a(s) 表示两个定义是等价的。

### 自动机 M 的状态图

自动机通常使用它的状态图 D = D(M) 来定义，而不是列出它的五个部分。状态图 D = D(M) 是如下的一种带标记的有向图。
    1. D(M) 的结点是 S 的状态，接受状态用双圈表示
    2. 在 D(M) 中，若 F(s_ j, a) = s_ k 或 f_ a(s_ j) = s_ k，则用一个标有输入a的箭头从 s_ j 指向 s_ k
    3. 初始状态 s_ 0 是通过一特殊的箭号表示，这个箭号终止于 s_ 0，但是没有初始结点。

### 自动机 M 决定的形式语言 L(M)

每一个有输入字母表 A 的自动机 M 定义 A 上的一种形式语言 L(M) 如下：
设 w = a1 a2 ... am 为A中的一字符串，则 w 确定一状态序列：

$$
s_0 \to s_1 \to s_2 \to \cdots \to s_m
$$

其中 s_0 为初始状态且 F(s_{i - 1}, a_i) = s_i(i >= 1)， 换句话说，w确定了状态图 D(M) 的路径：
$$
P = (s_0, a_1, s_1, a_2, s_2, \cdots, a_m, s_m)
$$

如果最后状态 s_m 是 Y 中的接受状态，则说 M 识别字符串 w。
M 的形式语言 L(M) 为 A中被 M 接受的所有字符串的集合。

定理 13.2（Kleene） 字母表 A 上的形式语言 L 是正则的当且仅当存在一个有限自动机 M 使得 L = L(M)。

（形式语言 L 上的 * 运算 L* 有时称作 L 的 Kleene 闭包）。

### Pumping引理

定理13.3 （Pumping引理） 假设 M 是 A 上的自动机并满足：
    1. M 有 k 个状态
    2. M 接受 A 的字符串 w，这里 |w| > k
  那么 w = xyz，这里对每一个正整数m，w_m = xy^m z 被 m 接受。

## 形式语法

一个**短语结构形式语法**，简称形式语法G，由四个部分构成：
    1. 一个有限集（**词汇**）V；
    2. V 的一个子集T，T 的元素称为**终结元**；集合 N = V\T 的元素称为 **非终结元** 或 **变元**；
    3. 一个非终结符 S 称为**起始符**；
    4. 一个产生式的有限集 P。产生式是一个有序偶(\alpha, \beta)，通常记作 \alpha \to \beta， 其中\alpha，\beta是 V 上的字符串；P 中的每个产生式的左端必须至少包括一个非终结元。
  这样的形式语法 G，记作 G = G(V, T, S, P)

除特别说明外，形式语法用下面的记法：终结元用斜体小写拉丁字母表示；非终结元用斜体大写拉丁字母表示；起始符用 S 表示；同时，V 中的字符串，即终结元 或 非终结元 的字符串用希腊字母表示，此外，将：
$$
\alpha \to \beta _1, \alpha \to \beta _2, \cdots, \alpha \to \beta _k
$$
记作：
$$
\alpha \to (\beta _1, \beta _2, \cdots, \beta _k)
$$

### 形式语法 G 的形式语言 L(G)

假设 w 和 w' 是形式语法 G 的词汇集合 V 上的字符串，如果 w' 能够由 w 通过使用一个产生式得到，我们写成：
$$
w \Rightarrow w'
$$

即，如果存在字符串 u 和 v，使得 w = u \alpha v 且 w' = u\beta v，并且有一个产生式 \alpha \to \beta，我们写成：
$$
w \Rightarrow \Rightarrow w', w^* \Rightarrow w'
$$
如果 w' 能够由 w 通过使用有限个产生式得到。

设 G 是一个形式语法，T 是 G 的终结元集。G 的形式语言，记作 L(G)；由初始符 S 通过以上过程得到 T 上的字符串组成，即：
$$
L(G) = \{ w \in T^*: s \Rightarrow\Rightarrow w \}
$$

### 形式语法的类型

#### Noam Chomsky分类法

形式语法根据所允许的产生式的种类来分类。
以下是 Noam Chomsky 提出的形式语法的分类：
    0. 一个零型形式语法在产生式上没有限制；
    1. 第一类型：如果形式语法 G 所有的产生式都是
$$
  \alpha \to \beta(|\alpha| \leq |\beta|), \alpha \to \lambda
$$
  2. 第二类型：如果形式语法 G 所有的产生式都是
     $$
     A \to \beta
     $$
     即其中左端是一个非终结元的形式

  3. 第三类型：如果形式语法 G 所有的产生式都是：

  4. $$
     A \to a, A \to aB, S \to \lambda
     $$
     即左端是一个非终结元，右端是一个终结元或一个终结元后跟一个非终结元；或起始符到空串。

可以看出，形式语法分类形式一个阶层组织，即第三类型的形式语法都是第二类型的；第二类型的形式语法都是第一类型的；第一类型的形式语法都是零类型形式语法。

#### 上下文相关性分类

形式语法也可以分类成上下文有关的法语、上下文无关的语法、正则的语法：

1. **上下文相关的语法**：一个形式语法 G，如果它的产生式都是：
$$
\alpha A \alpha ' \to \alpha \beta \alpha '
$$
称它是“上下文相关的”，是因为只有当变元A 在 \alpha 与 \alpha' 之间时，才总可以用\beta 来取代A。

2. **上下文无关的语法**： 一个形式语法 G，如果它的产生式都是：
$$
A \to \beta
$$
称它为“上下文无关的”，是因为无论变元A在什么位置，我们总可以用 \beta 来取代 A。

3. **正则的语法**：一个形式语法是正则的，如果它的产生式都是这样的形式：
$$
A \to a, A \to aB, S \to \lambda
$$

可以看出，上下文无关的形式语法与第二类型形式语法是第个的，正则形式语法与第三类型形式语法是等价的。

**定理13.4** 形式语言 L 能由第三类型（正则）形式语法 G 生成，当且仅当存在一个有限自动机 M 能够接受 L。
因此，一个形式语法是正则的，当且仅当 L = L(r)，其中r 是正则表达式；当且仅当 L = L(M)，其中 M 是有限状态自动机；当且仅当 L = L(G)，其中 G 是正则形式语法。

### 上下文无关语法的导出树

**导出树**：一个上下文无关的形式语法G，L(G) 中的字符串 w 的导出可以用有序、有根的树 T 来形象地描述，称为导出树。

### Backus-Naur形式

在描述上下文无关的形式语法（第二类型形式语法）的产生式时，有时也用另外一种词法，称作 Backus-Naur形式。它的特点在于：

    1. 不用 \to 而用 ::= ；
    2. 非终结元要用 <> 括起来；
    3. 所有左端有相同非终结元的产生式要合并成一句，所有的右端在 ::= 的右边列出并用短竖隔开；

### 自动机与形式语法

正则形式语法对应有限状态自动机（FSA）。此外，还有其他形式的自动机，对应其他形式的语法。
    1. **Pushdown自动机**：Pushdown自动机 P 与 FSA 类似，且 P 有一个辅助储存器能为它提供无限大容量的存储空间。
    形式语言L能被Pushdown自动机识别，当且仅当 L 是 *上下文无关* 的形式语言。
    2. **线性有界自动机**：线性有界自动机 B 比 Pushdown自动机的功能更强，这样的自动机 B 使用一种带子，这种带子是根据输入字符串 w 的字长而线性有界的。
     形式语言L 能被自动机B识别当且仅当 L 是 *上下文有关* 的。
    3. **Turing自动机**：Turing自动机，使用的是一种无限长的带子，它能识别由任何短语结构形式语法 G 生成的所有形式语言。   事实上，Turing自动机 M 是一系列定义可数函数的等价方法中的一种。

## 有限状态机

有限状态机（FSM）与有限状态自动机（FSA）类似，只是FSM输出时使用一种与输入字母表不同的输出字母表。正式定义如下：
有限状态机（或完全序列机）M由六个部分组成：
    1. 一个输入符的有限集 A
    2. 一个内部状态的有限集 S
    3. 一个输出符的有限集 Z
    4. S 中的一个初始状态 s_0
    5. 一个从 S\times A 到 S 状态转移函数 f
    6. 一个从 S\times A 到 Z 的输出函数 g
  这样的一个机器 M 被记作
$$
M = M(A, S, Z, s_0, f, g)
$$

### 有限状态机的状态表与状态图

描述有限状态机的方法通常有两种：一种是用表格，称作有限状态机 M 的状态表；另一种是用有标记的有向图，称作有限状态机的状态图。

**状态表**：状态表把状态转移函数 f 与 输出函数 g 放在同一个表格内，这个表格描述了由
$$
F(s_i, a_j) = (f(s_i, a_j), g(s_i, a_j))
$$
定义的函数
$$
F:S\times A \to S \times Z
$$

**状态图**：有限状态机 M = M(A, S, Z, s_0, f, g) 的状态图 D = D(M) 是一个有标记的有向图。D的结点是M的状态。此外，如果：
$$
F(s_i, a_j) = (s_k, z_r)
$$
亦即：
$$
f(s_i, a_j) = s_k \land g(s_i, a_j) = z_r
$$
那么，从 s_i 到 s_k 就有一条标着 a_j 和 z_r 的箭头。我们通常放输入符 a_j 靠近箭头的始端（靠近 s_i），输出符 z_r 靠近箭头的中心。此外，还通过另外画一条指向 s_0 的箭头来标记初始状态 s_0。

### 输入与输出带

设定给 M 一个输入符的字符串，如：
$$
u = a_1 a_2 \cdots a_m
$$
我们设想这些符号在一条“输入带”上，机器M一个一个地读这些输入符，同时进行一系列的状态转换：
$$
V = s_0 s_1 s_2 \cdots s_m
$$
其中 s_0 是初始状态，并且把输出符的字符串
$$
w = z_1 z_2 \cdots z_m
$$
打印在一条“输出带”上。准确地说，初始状态 s_0 和输入字符串 u 通过
$$
s_i = f(s_{i - 1}, a_i), z_i = g(s_{i - 1}, a_i)
$$
来决定字符串 v 和 w，其中 i = 1, 2, ..., m。

### 二进制加法

**定理13.5** 没有一种有限状态机能做二进制乘法。

## Gödel数

Gödel数：任何正整数 n (n > 1) 都能唯一地（除顺序外）写成素数的乘积，把数字的有限序列进行了编码，也把在有限或可数的字母表A上的字符上的字符串进行编码。每个序列或字符串按下面规则对应的正整数，叫做 Gödel数：
非负整数序列 s = (n_1, n_2, ..., n_k) 的Gödel数是正整数 c(s)，其中 n_i 是 c(s) 的素数分解式中 p_i 的指数，即：
$$
c(s) = p_1^{n_1} p_2^{n_2} \cdots p_k^{n_k}
$$

字母表 {a_0, a_1, a_2, a_3, ...} 上的字符串 w 的 Gödel数 是正整数 c(w)，其中w的第i个字母的下标是c(w)的素数分解式中的 p_i 的指数。

（可以看出两种编码本质上是一样的，因为我们可以将字符串 w 看成是它的字母的下标的序列）。

定理13.6 如果字母表 A 是可数的，那么 A 上的所有形式的语言 L 都是可数的。

## Turing机

基本定义

一个Turing机包括三个不交的非空集：
  1. 一个有限带集合：
    $$
    A = \{a_1, a_2, \cdots, a_m\} \cup {B}
    $$
    这里 B = a_0，是“空格”符
  2. 一个有限状态集：
    $$
    S = {s_1, s_2, \cdots, s_n} \cup {s_0} \cup {s_H, s_Y, s_N}
    $$
    这里 s_0 是初始状态。另外 SH(HALT)是停止状态, SY(YES)是接受状态, SN(NO)是不接受状态。
  3. 一个有向集
    $$
    d = {L, R, N}
    $$
    这里 L 表示“左”，R表示“右”，N表示“无运动”或“静止”。

**定义13.1** **表达**是 A \cup S \cup d 中的元素的一个有限（可能空）序列。

**定义13.2** **带表达**是只使用带集 A 中元素的表达。

**定义13.3** 一个格局 \alpha 是这样一个形状的表达：
$$
\alpha = P s_i a_k Q
$$
此处，P 和Q  是带表达（可能是空的）。

**定义13.4** 设 \alpha = P s_i a_k Q 是一个格局，我们说 Turing机M 处于 s_i 状态，而 s_i 扫描字母 a_k，在线带上的表达是表达 P a_k Q，也就是没有状态符号 s_i 的 \alpha。

**定义13.5** Turing机M是有限的五元组集合，满足：
    1. 没有两个五元组以相同的两个字母开始；
    2. 没有一个五元组是以 s_H, s_Y 或 s_N 开始；

下面是另一个等价的定义：
**定义13.6** Turing机M 是一个部分函数：
$$
S\setminus\{s_H, s_Y, s_N\} \times A \to A \times S \times d
$$
部分函数。简单地说，是表示 M 的定义域为
$$
S\setminus \{s_H, s_Y, s_N\}\times A
$$
的子集。

**定义13.7** 设 \alpha 和 \beta 是两个格局，我们写作：
$$
\alpha \to \beta
$$
如果下面中任何一个成立，此外 a,b,c 是线索字母，而P 和Q是线索表达（可能是空的）：
  1. \alpha = Ps_i aQ, \beta = Ps_j bQ 和 M 包含着五元组 q = s_i ab s_j N；
  2. \alpha = Ps_i acQ, \beta = Pbs_j cQ 和 M 包含着五元组 q = s_i abs_j R；
  3. \alpha = Pcs_i aQ, \beta = Ps_j cbQ 和 M 包含着五元组 q = s_i abs_j L；
  4. \alpha = Ps_i a，\beta = Pbs_jB 和 M 包含着五元组 q = s_i abs_j R；
  5. \alpha = s_i aQ，\beta = s_jBbQ 和 M 包含着五元组 q = s_i abs_j L；

注意，在所有五种情况中，M用b在线带中代替了 a（此外我们允许 b = a），M改变了它的状态，从s_i 到 s_j（此处我们允许s_j = s_i），还有：
  1. 这里M不移动
  2. 这里M向右移动
  3. 这里M向左移动
  4. 这里M向右移动，但是，因为 M 正扫描最右面的字母，它必须在右边加上空格符B
  5. 这里M向左移动，但是，因为 M 正扫描最左面的字母，它必须在左边加上空格符B

**定义13.8** 格局\alpha 是终止的，如果没有格局\beta，使得\alpha \to \beta。

### 用Turing机计算

**定义13.9** Turing机 的一个计算是一列格局 \alpha_0, \alpha_1, ..., \alpha _m，满足 \alpha_{i - 1} \to \alpha_{i} (i = 1, ..., m) 以及 \alpha_m 是终止格局。
换句话说，一个计算是一个序列：
$$
\alpha_0 \to \alpha_1 \to \alpha_2 \to \cdots \alpha_m
$$
这个序列不能再延续，因为 a_m 是终止的。我们用 term(\alpha)来表示以 \alpha 开始的计算的最后格局，因此，在上面的计算中，term(\alpha_0) = \alpha_m

### Turing机的输入

**定义13.10** Turing机 M 的一个输入是一个线索表达 W。输入W的初始格局是 \alpha(W)，此处 \alpha(W) = s_0 W。

**定义13.11** 设 M 是一个Turing机，W 是一个输入，如果有一个计算以初始格局 \alpha(W)开始，我们说 M 停止于 W 处。
也就是，给出一个输入W，我们能形成初始格局 \alpha(W) = s_0 W，并且应用 M 去获得一个序列：
$$
\alpha(W) \to \alpha_1 \to \alpha_2 \to cdots
$$
两种情况可能发生：
  1. M 停止在 W 处，也就是说，序列在终止格局 \alpha_r处结束
  2. M 在 W 处 没有停止，也就是说，序列不会结束

### 形式语法和Turing机

**定理13.7** 形式语言 L 能被 Turing机 M 识别，当且仅当 L 是一个类型 0 的形式语言。

## 可计算的函数

用N来表示正整数的集合，记 N_0：
$$
N_0 = \{ 0, 1, 2, 3, \cdots \}
$$

**定义13.12** 每个数字 n 将通过带表达<n>表示；此处<n> = 1^{n + 1}，这样：
$$
\langle 0\rangle = 1, \langle 2\rangle = 111 = 1^3, \langle 4\rangle = 11111 = 1^5
$$

**定义13.13** 设E是一个表达，那么[E]将用来表示在 E 中1出现的次数，因此：
$$
[11B s_2 a_3 111Ba_4] = 5, [a_4 s_2 B a_2] = 0, [\langle n \rangle] = n + 1
$$

**定义13.14** 函数 f: N_0 \to N_0 是可计算的，如果存在一个 Turing机 M 使得对每个整数 n，M 停止在<n>并且：
$$
f(n) = [term(\alpha(\langle n \rangle))]
$$
此时，说 M 计算了 f。

**定义13.8** 假设 f: N_0 \to N_0，和 g: N_0 \to N_0 是可计算的，那么复合函数 h = g * f 也是可计算的。

### 多元函数

**定义13.15** 每一个 k 个整数的目录 m = (n_1, n_2, \cdots, n_k) 由带表达<m>表示，这里：
$$
\langle m \rangle = \langle n_1 \rangle B \langle n_2 \rangle B \cdots B \langle n_k \rangle
$$
（因此， <(2,0,4)> = 111B1B11111 = 1^3 B 1^1 B 1^5）

**定义13.16** 一个k元函数f(n_1, n_2, \cdots, n_k) 是可计算的，如果存在一个Turing机M，使得对每一个目录 m = (n_1, n_2, ..., n_k)，M 停止在 <m> 处，并且：
$$
f(m) = [term(\alpha(\langle m \rangle))]
$$
那么我们说 M 可计算 f。
